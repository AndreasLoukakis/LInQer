({Enumerable:Enumerable,EqualityComparer:EqualityComparer}=function(){function t(t){if(!t)throw new Error("Only iterables or bound functions that return iterators are acceptable");"function"==typeof t?(this._src=t,this._generator=t):(e(t),this._src=t,this._generator=t[Symbol.iterator].bind(t)),this._canSeek=!1,this._count=null,this._tryGetAt=null,this._wasIterated=!1}function n(t,n,e){this._src=t,this._canSeek=!1,this._count=null,this._tryGetAt=null,this._wasIterated=!1,this._keySelectors=[{keySelector:n,ascending:e}],this._generator=function*(){const t=i(this._src);t.sort((t,n)=>{for(const e of this._keySelectors){const o=e.keySelector(t),r=e.keySelector(n);if(o>r)return e.ascending?1:-1;if(o<r)return e.ascending?-1:1}return 0});for(const n of t)yield n},this._count=this._src.count.bind(this._src)}function e(t){if(!t||!t[Symbol.iterator])throw new Error("the argument must be iterable!")}function o(t){if(!t||"function"!=typeof t)throw new Error("the argument needs to be a function!")}function r(t){return"number"==typeof t?t:Number.NaN}function i(t){return t?Array.isArray(t)?t:Array.from(t):[]}function s(t){t._count||("number"!=typeof t._src.length?"number"!=typeof t._src.size?t._count=()=>{let n=0;for(const e of t)n++;return n}:t._count=()=>t._src.size:t._count=()=>t._src.length)}function c(t){t._tryGetAt||(this._canSeek=!0,"string"!=typeof t._src?Array.isArray(t._src)?t._tryGetAt=n=>n>=0&&n<t._src.length?{value:t._src[n]}:null:"number"!=typeof t._src.length?(this._canSeek=!1,t._tryGetAt=n=>{let e=0;for(const o of t){if(n===e)return{value:o};e++}return null}):t._tryGetAt=n=>n<t._src.length&&void 0!==t._src[n]?{value:t._src[n]}:null:t._tryGetAt=n=>n<t._src.length?{value:t._src.charAt(n)}:null)}t.empty=function(){const n=new t([]);return n._count=()=>0,n._tryGetAt=t=>null,n},t.range=function(n,e){const o=new t(function*(){for(let t=0;t<e;t++)yield n+t}.bind(this));return o._count=()=>e,o._tryGetAt=t=>t>=0&&t<e?{value:n+t}:null,o},t.repeat=function(n,e){const o=new t(function*(){for(let t=0;t<e;t++)yield n}.bind(this));return o._count=()=>e,o._tryGetAt=t=>t>=0&&t<e?{value:n}:null,o},t.from=function(n){return n instanceof t?n:new t(n)},t.prototype={[Symbol.iterator](){return this._wasIterated=!0,this._generator()},aggregate(t,n){o(n);for(const e of this)t=n(t,e);return t},all(t){return o(t),!this.any(n=>!t(n))},any(t){o(t);for(const n of this)if(t(n))return!0;return!1},append(t){return this.concat([t])},average(){const t={count:0};for(const n of this)t.sum=0===t.count?r(n):t.sum+r(n),t.count++;return 0==t.count?void 0:t.sum/t.count},asEnumerable(){return this},cast(t){const n="string"==typeof t?n=>typeof n===t:n=>n instanceof t;return this.where(e=>{if(!n(e))throw new Error(e+" not of type "+t);return!0})},concat(n){e(n);const o=new t(function*(){for(const t of this)yield t;for(const t of n)yield t}.bind(this)),r=this;return o._count=()=>{const e=new t(n);return r.count()+e.count()},o},contains(t,n=u.default){return o(n),this.any(e=>n(e,t))},count(){return s(this),this._count()},defaultIfEmpty(){throw new Error("defaultIfEmpty not implemented for Javascript")},distinct(n=u.default){return new t((n===u.default?function*(){const t=new Set;for(const n of this){const e=t.size;t.add(n),e<t.size&&(yield n)}}:function*(){const t=[];for(const e of this){let o=!0;for(const r of t)if(n(e,r)){o=!1;break}o&&(yield e),t.push(e)}}).bind(this))},elementAt(t){c(this);const n=this._tryGetAt(t);if(!n)throw new Error("Index out of range");return n.value},elementAtOrDefault(t){c(this);const n=this._tryGetAt(t);if(n)return n.value},except(n,o=u.default){return e(n),new t((o===u.default?function*(){const t=new Set(n);for(const n of this)t.has(n)||(yield n)}:function*(){const t=i(n);for(const n of this){let e=!0;for(const r of t)if(o(n,r)){e=!1;break}e&&(yield n)}}).bind(this))},first(){return this.elementAt(0)},firstOrDefault(){return this.elementAtOrDefault(0)},groupBy(n){o(n);return new t(function*(){const e=new Map;for(const t of this){const o=n(t),r=e.get(o);r?r.push(t):e.set(o,[t])}for(const n of e){const e=new t(n[1]);e.key=n[0],yield e}}.bind(this))},groupJoin(n,e,o,r,s=u.default){const c=s===u.default?function*(){const s=new t(n).groupBy(o).toMap(t=>t.key,t=>t);for(const t of this){const n=i(s.get(e(t)));yield r(t,n)}}:function*(){for(const t of this){const i=[];for(const r of n)s(e(t),o(r))&&i.push(r);yield r(t,i)}};return new t(c.bind(this))},intersect(n,o=u.default){return e(n),new t((o===u.default?function*(){const t=new Set(n);for(const n of this)t.has(n)&&(yield n)}:function*(){const t=i(n);for(const n of this){let e=!0;for(const r of t)if(o(n,r)){e=!1;break}e||(yield n)}}).bind(this))},join(n,e,o,r,i=u.default){const s=i===u.default?function*(){const i=new t(n).groupBy(o).toMap(t=>t.key,t=>t);for(const t of this){const n=i.get(e(t));if(n)for(const e of n)yield r(t,e)}}:function*(){for(const t of this)for(const s of n)i(e(t),o(s))&&(yield r(t,s))};return new t(s.bind(this))},last(){if(c(this),!this._canSeek){let t=null,n=!1;for(const e of this)t=e,n=!0;if(n)return t;throw new Error("The enumeration is empty")}const t=this.count();return this.elementAt(t-1)},lastOrDefault(){if(c(this),!this._canSeek){let t=void 0;for(const n of this)t=n;return t}const t=this.count();return this.elementAtOrDefault(t-1)},longCount(){return this.count()},max(t){return void 0!==t?o(t):t=(t,n)=>t>n?1:t<n?-1:0,this.aggregate(void 0,(n,e)=>void 0===n||t(e,n)>0?e:n)},min(t){return void 0!==t?o(t):t=(t,n)=>t>n?1:t<n?-1:0,this.aggregate(void 0,(n,e)=>void 0===n||t(e,n)<0?e:n)},ofType(t){const n="string"==typeof t?n=>typeof n===t:n=>n instanceof t;return this.where(n)},orderBy(t){return t?o(t):t=t=>t,new n(this,t,!0)},orderByDescending(t){return t?o(t):t=t=>t,new n(this,t,!1)},prepend(n){return new t([n]).concat(this)},reverse(){c(this);const n=new t((this._canSeek?function*(){for(let t=this.count()-1;t>=0;t--)yield this.elementAt(t)}:function*(){const t=i(this);for(let n=t.length-1;n>=0;n--)yield t[n]}).bind(this));return s(this),n._count=this._count,n},select(n){o(n);const e=new t(function*(){for(const t of this)yield n(t)}.bind(this));return s(this),e._count=this._count,e},selectMany(n){void 0!==n?o(n):n=t=>t;return new t(function*(){for(const t of this){e(t);for(const e of n(t))yield e}}.bind(this))},sequenceEqual(t,n=u.default){e(t),o(n);const r=this[Symbol.iterator](),i=t[Symbol.iterator]();let s=!1;do{const t=r.next(),e=i.next();if(!(t.done&&e.done||!t.done&&!e.done&&n(t.value,e.value)))return!1;s=t.done}while(!s);return!0},single(){const t=this[Symbol.iterator]();let n=t.next();if(n.done)throw new Error("Sequence contains no elements");const e=n.value;if(n=t.next(),!n.done)throw new Error("Sequence contains more than one element");return e},singleOrDefault(){const t=this[Symbol.iterator]();let n=t.next();if(n.done)return;const e=n.value;if(n=t.next(),!n.done)throw new Error("Sequence contains more than one element");return e},skip(n){const e=new t(function*(){let t=n;for(const n of this)t>0?t--:yield n}.bind(this)),o=this;return e._count=()=>Math.max(0,o.count()-n),e},skipLast(n){const e=new t(function*(){let t=n;const e=Array(t);let o=0,r=0;for(const n of this){const i=e[o-r];e[o-r]=n,o++,o-r>=t&&(r+=t),o>t&&(yield i)}e.length=0}.bind(this)),o=this;return e._count=()=>Math.max(0,o.count()-n),e},skipWhile(n){o(n);let e=!0;return new t(function*(){for(const t of this)e&&!n(t)&&(e=!1),e||(yield t)}.bind(this))},sum(){const t={count:0};for(const n of this)t.sum=0===t.count?r(n):t.sum+r(n),t.count++;return 0==t.count?void 0:t.sum},take(n){const e=new t(function*(){let t=n;for(const n of this)if(t>0&&(yield n,t--),t<=0)break}.bind(this)),o=this;return e._count=()=>Math.min(n,o.count()),e},takeLast(n){c(this);const e=new t((this._canSeek?function*(){let t=n;const e=this.count();for(let n=e-t;n<e;n++)yield this.elementAt(n)}:function*(){let t=n,e=0;const o=Array(t);for(const n of this)o[e%t]=n,e++;for(let n=0;n<t&&n<e;n++)yield o[(e+n)%t]}).bind(this)),o=this;return e._count=()=>Math.min(n,o.count()),e},takeWhile(n){o(n);return new t(function*(){for(const t of this){if(!n(t))break;yield t}}.bind(this))},toArray(){return Array.from(this)},toDictionary(){throw new Error("use toMap or toObject instead of toDictionary")},toMap(t,n=(t=>t)){o(t),o(n);const e=new Map;for(const o of this)e.set(t(o),n(o));return e},toObject(t,n=(t=>t)){o(t),o(n);const e={};for(const o of this)e[t(o)]=n(o);return e},toHashSet(){throw new Error("use toSet instead of toHashSet")},toSet(){const t=new Set;for(const n of this)t.add(n);return t},toList(){throw new Error("use toArray instead of toList")},toLookup(){throw new Error("use toObject instead of toLookup")},union(t,n=u.default){return e(t),this.concat(t).distinct(n)},where(n){o(n);return new t(function*(){let t=0;for(const e of this)n(e,t)&&(yield e),t++}.bind(this))},zip(n,r){e(n),o(r);return new t(function*(){let t=0;const e=this[Symbol.iterator](),o=n[Symbol.iterator]();let i=!1;do{const n=e.next(),s=o.next();i=n.done||s.done,i||(yield r(n.value,s.value,t)),t++}while(!i)}.bind(this))}},n.prototype={thenBy(t){return this._keySelectors.push({keySelector:t,ascending:!0}),this},thenByDescending(t){return this._keySelectors.push({keySelector:t,ascending:!1}),this}},Object.setPrototypeOf(n.prototype,t.prototype);const u={default:(t,n)=>t==n,exact:(t,n)=>t===n};return{Enumerable:t,EqualityComparer:u}}());