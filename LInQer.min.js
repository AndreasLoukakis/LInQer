({Enumerable:Enumerable,EqualityComparer:EqualityComparer}=function(){function t(t){if(!t)throw new Error("Only iterables or bound functions that return iterators are acceptable");"function"==typeof t?(this._src=t,this._generator=t):(n(t),this._src=t,this._generator=t[Symbol.iterator].bind(t)),this._canSeek=!1,this._count=null,this._tryGetAt=null,this._wasIterated=!1}function n(t){if(!t||!t[Symbol.iterator])throw new Error("the argument must be iterable!")}function e(t){if(!t||"function"!=typeof t)throw new Error("the argument needs to be a function!")}function o(t){return"number"==typeof t?t:Number.NaN}function r(t){return Array.isArray(t)?t:Array.from(t)}function i(t){t._count||("number"!=typeof t._src.length?"number"!=typeof t._src.size?t._count=()=>{let n=0;for(const e of t)n++;return n}:t._count=()=>t._src.size:t._count=()=>t._src.length)}function s(t){t._tryGetAt||(this._canSeek=!0,"string"!=typeof t._src?Array.isArray(t._src)?t._tryGetAt=n=>n>=0&&n<t._src.length?{value:t._src[n]}:null:"number"!=typeof t._src.length?(this._canSeek=!1,t._tryGetAt=n=>{let e=0;for(const o of t){if(n===e)return{value:o};e++}return null}):t._tryGetAt=n=>n<t._src.length&&void 0!==t._src[n]?{value:t._src[n]}:null:t._tryGetAt=n=>n<t._src.length?{value:t._src.charAt(n)}:null)}t.empty=function(){const n=new t([]);return n._count=()=>0,n._tryGetAt=t=>null,n},t.range=function(n,e){const o=new t(function*(){for(let t=0;t<e;t++)yield n+t}.bind(this));return o._count=()=>e,o._tryGetAt=t=>t>=0&&t<e?{value:n+t}:null,o},t.repeat=function(n,e){const o=new t(function*(){for(let t=0;t<e;t++)yield n}.bind(this));return o._count=()=>e,o._tryGetAt=t=>t>=0&&t<e?{value:n}:null,o},t.from=function(n){return n instanceof t?n:new t(n)},t.prototype={[Symbol.iterator](){return this._wasIterated=!0,this._generator()},aggregate(t,n){e(n);for(const e of this)t=n(t,e);return t},all(t){return e(t),!this.any(n=>!t(n))},any(t){e(t);for(const n of this)if(t(n))return!0;return!1},append(t){return this.concat([t])},average(){const t={count:0};for(const n of this)t.sum=0===t.count?o(n):t.sum+o(n),t.count++;return 0==t.count?void 0:t.sum/t.count},asEnumerable(){return this},cast(t){const n="string"==typeof t?n=>typeof n===t:n=>n instanceof t;return this.where(e=>{if(!n(e))throw new Error(e+" not of type "+t);return!0})},concat(e){n(e);const o=new t(function*(){for(const t of this)yield t;for(const t of e)yield t}.bind(this)),r=this;return o._count=()=>{const n=new t(e);return r.count()+n.count()},o},contains(t,n=u.default){return e(n),this.any(e=>n(e,t))},count(){return i(this),this._count()},defaultIfEmpty(){throw new Error("defaultIfEmpty not implemented for Javascript")},distinct(n=u.default){return new t((n===u.default?function*(){const t=new Set;for(const n of this){const e=t.size;t.add(n),e<t.size&&(yield n)}}:function*(){const t=[];for(const e of this){let o=!0;for(const r of t)if(n(e,r)){o=!1;break}o&&(yield e),t.push(e)}}).bind(this))},elementAt(t){s(this);const n=this._tryGetAt(t);if(!n)throw new Error("Index out of range");return n.value},elementAtOrDefault(t){s(this);const n=this._tryGetAt(t);if(n)return n.value},except(e,o=u.default){return n(e),new t((o===u.default?function*(){const t=new Set(e);for(const n of this)t.has(n)||(yield n)}:function*(){const t=r(e);for(const n of this){let e=!0;for(const r of t)if(o(n,r)){e=!1;break}e&&(yield n)}}).bind(this))},first(){return this.elementAt(0)},firstOrDefault(){return this.elementAtOrDefault(0)},groupBy(n){e(n);return new t(function*(){const e=new Map;for(const t of this){const o=n(t),r=e.get(o);r?r.push(t):e.set(o,[t])}for(const n of e){const e=new t(n[1]);e.key=n[0],yield e}}.bind(this))},groupJoin(){throw new Error("groupJoin not implemented for Javascript")},intersect(e,o=u.default){return n(e),new t((o===u.default?function*(){const t=new Set(e);for(const n of this)t.has(n)&&(yield n)}:function*(){const t=r(e);for(const n of this){let e=!0;for(const r of t)if(o(n,r)){e=!1;break}e||(yield n)}}).bind(this))},join(){throw new Error("join is not implemented for Javascript")},last(){if(s(this),!this._canSeek){let t=null,n=!1;for(const e of this)t=e,n=!0;if(n)return t;throw new Error("The enumeration is empty")}const t=this.count();return this.elementAt(t-1)},lastOrDefault(){if(s(this),!this._canSeek){let t=void 0;for(const n of this)t=n;return t}const t=this.count();return this.elementAtOrDefault(t-1)},longCount(){return this.count()},max(t){return void 0!==t?e(t):t=(t,n)=>t>n?1:t<n?-1:0,this.aggregate(void 0,(n,e)=>void 0===n||t(e,n)>0?e:n)},min(t){return void 0!==t?e(t):t=(t,n)=>t>n?1:t<n?-1:0,this.aggregate(void 0,(n,e)=>void 0===n||t(e,n)<0?e:n)},ofType(t){const n="string"==typeof t?n=>typeof n===t:n=>n instanceof t;return this.where(n)},orderBy(n){void 0!==n&&e(n);const o=new t(function*(){const t=r(this);n?t.sort((t,e)=>{const o=n(t),r=n(e);return o>r?1:o<r?-1:0}):t.sort();for(const n of t)yield n}.bind(this));return i(this),o._count=this._count,o},orderByDescending(t){return this.orderBy(t).reverse()},prepend(n){return new t([n]).concat(this)},reverse(){s(this);const n=new t((this._canSeek?function*(){for(let t=this.count()-1;t>=0;t--)yield this.elementAt(t)}:function*(){const t=r(this);for(let n=t.length-1;n>=0;n--)yield t[n]}).bind(this));return i(this),n._count=this._count,n},select(n){e(n);const o=new t(function*(){for(const t of this)yield n(t)}.bind(this));return i(this),o._count=this._count,o},selectMany(o){void 0!==o?e(o):o=t=>t;return new t(function*(){for(const t of this){n(t);for(const n of o(t))yield n}}.bind(this))},sequenceEqual(t,o=u.default){n(t),e(o);const r=this[Symbol.iterator](),i=t[Symbol.iterator]();let s=!1;do{const t=r.next(),n=i.next();if(!(t.done&&n.done||!t.done&&!n.done&&o(t.value,n.value)))return!1;s=t.done}while(!s);return!0},single(){const t=this[Symbol.iterator]();let n=t.next();if(n.done)throw new Error("Sequence contains no elements");const e=n.value;if(n=t.next(),!n.done)throw new Error("Sequence contains more than one element");return e},singleOrDefault(){const t=this[Symbol.iterator]();let n=t.next();if(n.done)return;const e=n.value;if(n=t.next(),!n.done)throw new Error("Sequence contains more than one element");return e},skip(n){const e=new t(function*(){let t=n;for(const n of this)t>0?t--:yield n}.bind(this)),o=this;return e._count=()=>Math.max(0,o.count()-n),e},skipLast(n){const e=new t(function*(){let t=n;const e=Array(t);let o=0,r=0;for(const n of this){const i=e[o-r];e[o-r]=n,o++,o-r>=t&&(r+=t),o>t&&(yield i)}e.length=0}.bind(this)),o=this;return e._count=()=>Math.max(0,o.count()-n),e},skipWhile(n){e(n);let o=!0;return new t(function*(){for(const t of this)o&&!n(t)&&(o=!1),o||(yield t)}.bind(this))},sum(){const t={count:0};for(const n of this)t.sum=0===t.count?o(n):t.sum+o(n),t.count++;return 0==t.count?void 0:t.sum},take(n){const e=new t(function*(){let t=n;for(const n of this)if(t>0&&(yield n,t--),t<=0)break}.bind(this)),o=this;return e._count=()=>Math.min(n,o.count()),e},takeLast(n){s(this);const e=new t((this._canSeek?function*(){let t=n;const e=this.count();for(let n=e-t;n<e;n++)yield this.elementAt(n)}:function*(){let t=n,e=0;const o=Array(t);for(const n of this)o[e%t]=n,e++;for(let n=0;n<t&&n<e;n++)yield o[(e+n)%t]}).bind(this)),o=this;return e._count=()=>Math.min(n,o.count()),e},takeWhile(n){e(n);return new t(function*(){for(const t of this){if(!n(t))break;yield t}}.bind(this))},thenBy(t){throw new Error("thenBy not implemented for Javascript")},thenByDescending(t){throw new Error("thenByDescending not implemented for Javascript")},toArray(){return Array.from(this)},toDictionary(){throw new Error("use toMap or toObject instead of toDictionary")},toMap(t,n=(t=>t)){e(t),e(n);const o=new Map;for(const e of this)o.set(t(e),n(e));return o},toObject(t,n=(t=>t)){e(t),e(n);const o={};for(const e of this)o[t(e)]=n(e);return o},toHashSet(){throw new Error("use toSet instead of toHashSet")},toSet(){const t=new Set;for(const n of this)t.add(n);return t},toList(){throw new Error("use toArray instead of toList")},toLookup(){throw new Error("use toObject instead of toLookup")},union(t){return n(t),this.concat(t).distinct()},where(n){e(n);return new t(function*(){let t=0;for(const e of this)n(e,t)&&(yield e),t++}.bind(this))},zip(o,r){n(o),e(r);return new t(function*(){let t=0;const n=this[Symbol.iterator](),e=o[Symbol.iterator]();let i=!1;do{const o=n.next(),s=e.next();i=o.done||s.done,i||(yield r(o.value,s.value,t)),t++}while(!i)}.bind(this))}};const u={default:(t,n)=>t==n,exact:(t,n)=>t===n};return{Enumerable:t,EqualityComparer:u}}());