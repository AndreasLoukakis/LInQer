"use strict";var Linqer;!function(t){t.Enumerable.prototype.shuffle=function(){const e=this;const n=t.Enumerable.from((function*(){const t=Array.from(e),n=t.length;let r=0;for(;r<n;){let e=r+Math.floor(Math.random()*(n-r));const o=t[e];t[e]=t[r],t[r]=o,r++,yield o}}));return n._count=()=>e.count(),n},t.Enumerable.prototype.randomSample=function(e,n=Number.MAX_SAFE_INTEGER){let r=0;const o=[];if(t._ensureInternalTryGetAt(this),this._canSeek){const t=this.count();let r=0;for(r=0;r<e&&r<n&&r<t;r++)o.push(this.elementAt(r));let a=Math.exp(Math.log(Math.random())/e);for(;r<t&&r<n;)r+=Math.floor(Math.log(Math.random())/Math.log(1-a))+1,r<t&&r<n&&(o[Math.floor(Math.random()*e)]=this.elementAt(r),a*=Math.exp(Math.log(Math.random())/e))}else for(const t of this){if(r<e)o.push(t);else{const n=Math.floor(Math.random()*r);n<e&&(o[n]=t)}if(r++,r>=n)break}return t.Enumerable.from(o)},t.Enumerable.prototype.distinctByHash=function(e){const n=this;return new t.Enumerable((function*(){const t=new Set;for(const r of n){const n=t.size;t.add(e(r)),n<t.size&&(yield r)}}))},t.Enumerable.prototype.exceptByHash=function(e,n){t._ensureIterable(e);const r=this;return new t.Enumerable((function*(){const o=t.Enumerable.from(e).select(n).toSet();for(const t of r)o.has(n(t))||(yield t)}))},t.Enumerable.prototype.intersectByHash=function(e,n){t._ensureIterable(e);const r=this;return new t.Enumerable((function*(){const o=t.Enumerable.from(e).select(n).toSet();for(const t of r)o.has(n(t))&&(yield t)}))},t.Enumerable.prototype.binarySearch=function(e,n=t._defaultComparer){let r=this;t._ensureInternalTryGetAt(this),this._canSeek||(r=t.Enumerable.from(Array.from(this)));let o=0,a=r.count()-1;for(;o<=a;){const t=o+a>>1,s=n(r.elementAt(t),e);if(0==s)return t;s<0?o=t+1:a=t-1}return!1},t.Enumerable.prototype.lag=function(e,n){if(!e)throw new Error("offset has to be positive");if(e<0)throw new Error("offset has to be positive. Use .lead if you want to join with next items");n?t._ensureFunction(n):n=(t,e)=>[t,e];const r=this;t._ensureInternalTryGetAt(this);const o=new t.Enumerable((function*(){const t=Array(e);let o=0;for(const a of r){const r=o-e,s=r<0?void 0:t[r%e];yield n(a,s),t[o%e]=a,o++}}));return o._count=()=>{const t=r.count();return o._wasIterated||(o._wasIterated=r._wasIterated),t},r._canSeek&&(o._canSeek=!0,o._tryGetAt=t=>{const o=r._tryGetAt(t),a=r._tryGetAt(t-e);return o?{value:n(o.value,a?a.value:void 0)}:null}),o},t.Enumerable.prototype.lead=function(e,n){if(!e)throw new Error("offset has to be positive");if(e<0)throw new Error("offset has to be positive. Use .lag if you want to join with previous items");n?t._ensureFunction(n):n=(t,e)=>[t,e];const r=this;t._ensureInternalTryGetAt(this);const o=new t.Enumerable((function*(){const t=Array(e);let o=0;for(const a of r){const r=o-e;if(r>=0){const o=t[r%e];yield n(o,a)}t[o%e]=a,o++}for(let r=0;r<e;r++){const a=t[(o+r)%e];yield n(a,void 0)}}));return o._count=()=>{const t=r.count();return o._wasIterated||(o._wasIterated=r._wasIterated),t},r._canSeek&&(o._canSeek=!0,o._tryGetAt=t=>{const o=r._tryGetAt(t),a=r._tryGetAt(t-e);return o?{value:n(o.value,a?a.value:void 0)}:null}),o},t.Enumerable.prototype.padEnd=function(e,n){if(e<=0)throw new Error("minLength has to be positive.");let r;r="function"!=typeof n?t=>n:n;const o=this;t._ensureInternalTryGetAt(this);const a=new t.Enumerable((function*(){let t=0;for(const e of o)yield e,t++;for(;t<e;t++)yield r(t)}));return a._count=()=>{const t=Math.max(e,o.count());return a._wasIterated||(a._wasIterated=o._wasIterated),t},o._canSeek&&(a._canSeek=!0,a._tryGetAt=t=>{const n=o._tryGetAt(t);return n||(t<e?{value:r(t)}:null)}),a},t.Enumerable.prototype.padStart=function(e,n){if(e<=0)throw new Error("minLength has to be positive.");let r;r="function"!=typeof n?t=>n:n;const o=this;t._ensureInternalTryGetAt(o);const a=new t.Enumerable((function*(){const t=Array(e);let n=0;const a=o[Symbol.iterator]();let s=!1,u=!1;do{const o=a.next();if(u=!!o.done,u||(t[n]=o.value,n++),s&&!u)yield o.value;else if(u||n===e){for(let t=0;t<e-n;t++)yield r(t);for(let e=0;e<n;e++)yield t[e];s=!0}}while(!u)}));return a._count=()=>{const t=Math.max(e,o.count());return a._wasIterated||(a._wasIterated=o._wasIterated),t},o._canSeek&&(a._canSeek=!0,a._tryGetAt=t=>{const n=o.count(),a=e-n;return a<=0?o._tryGetAt(t):t<a?{value:r(t)}:o._tryGetAt(t-a)}),a}}(Linqer||(Linqer={}));